# Part 2: Bottom-Up Parser

This part comprises:

* My own hand-written tokeniser/lexer.

* A bottom-up parser generated by the Happy parser generator.

* A parse tree pretty-printing function.

## Contents

* `bottomUp.hs`:   The parser generated by Happy.

* `bottomUp.info`: Interesting information about the states and transitions of
                   the above parser.

* `bottomUp.y`:    The parser description required by Happy, used to generate
                   the parser. This uses a combination of Backus-Naur Form to
                   describe the grammar, and templated Haskell code to
                   implement it.

* `printTree.hs`:  The parse tree pretty-printer.

* `tokeniser.hs`:  The tokeniser written for this grammar.

## Instructions

### String Parsing

To execute the parser, you must first ensure that the Glasgow Haskell Compiler
(GHC) is installed on your system. This code was tested with GHC 8.0.1.

You can then test the parser with a method similar to the following:

```
[Will@Wills-MacBook-Air ~/parsing/src/part2 13:25:22]
$ echo '(3 + 4) * 3' | runhaskell bottomUp.hs
T (Mul (F (Parens (Plus (T (F (Int 3))) (F (Int 4))))) (Int 3))

[Will@Wills-MacBook-Air ~/parsing/src/part2 13:26:04]
$ echo 'invalid 321' | runhaskell bottomUp.hs
bottomUp.hs: Parse error
CallStack (from HasCallStack):
  error, called at bottomUp.hs:247:16 in main:BottomUp
```

### Parse Tree Pretty-Printing

You can test parse tree pretty-printing with a method similar to the following:

```
[Will@Wills-MacBook-Air ~/parsing/src/part2 14:04:52]
$ echo '(1 + 1)' | runhaskell printTree.hs
E
|
`- T
   |
   `- F: ()
      |
      `- E: +
         |
         +- E
         |  |
         |  `- T
         |     |
         |     `- F: 1
         |
         `- T
            |
            `- F: 1
```
