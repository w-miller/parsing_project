# Part 2: Bottom-Up Parser

This part comprises:

* A hand-written tokeniser/lexer.

* A bottom-up parser generated by the Happy parser generator.

* A hand-written parse tree pretty-printing program.

* A hand-written parse tree evaluation program.

## Contents

* `bottomUp.hs`:   The parser generated by Happy.

* `bottomUp.info`: Interesting information about the states and transitions of
                   the above parser.

* `bottomUp.y`:    The parser description required by Happy, used to generate
                   the parser. This uses a combination of Backus-Naur Form to
                   describe the grammar, and templated Haskell code to
                   implement it.

* `evaluate.hs`:   The parse tree evaluation program.

* `printTree.hs`:  The parse tree pretty-printer.

* `tokeniser.hs`:  The tokeniser written for this grammar.

## Instructions

### String Parsing

To execute the parser, you must first ensure that the Glasgow Haskell Compiler
(GHC) is installed on your system. This code was tested with GHC 8.0.1.

You can then test the parser with a method similar to the following:

```
[Will@Wills-MacBook-Air ~/parsing/src/part2 13:25:22]
$ echo '(3 + 4) * 3' | runhaskell bottomUp.hs
T (Mul (F (Parens (Plus (T (F (Int 3))) (F (Int 4))))) (Int 3))

[Will@Wills-MacBook-Air ~/parsing/src/part2 13:26:04]
$ echo 'invalid 321' | runhaskell bottomUp.hs
bottomUp.hs: Parse error
CallStack (from HasCallStack):
  error, called at bottomUp.hs:247:16 in main:BottomUp
```

### Parse Tree Pretty-Printing

You can test parse tree pretty-printing with a method similar to the following:

```
[Will@Wills-MacBook-Air ~/parsing/src/part2 14:04:52]
$ echo '(1 + 1)' | runhaskell printTree.hs
E
|
`- T
   |
   `- F: ()
      |
      `- E: +
         |
         +- E
         |  |
         |  `- T
         |     |
         |     `- F: 1
         |
         `- T
            |
            `- F: 1
```

### Parse Tree Evaluation

Evaluation of expressions can be performed by providing integer values for
variables at run-time. Like the previous sections, the expression is taken from
stdin; variable bindings are taken as key-value pairs in the format `x=1`, each
as separate command-line arguments.

You can evaluate an expression with a method similar to the following:

```
[Will@Wills-MacBook-Air ~/parsing/src/part2 15:28:40]
$ echo '(a+1)*3-b' | runhaskell -Wall evaluate.hs a=5 b=4
14

[Will@Wills-MacBook-Air ~/parsing/src/part2 15:28:46]
$ echo '(a+1)*3-b/c' | runhaskell -Wall evaluate.hs a=5 b=4
evaluate.hs: The symbol 'c' was not defined.
CallStack (from HasCallStack):
  error, called at evaluate.hs:31:20 in main:Evaluate
```
